			     BASH PATCH REPORT
			     =================

Bash-Release: 3.2
Patch-ID: bash32-001

Bug-Reported-by:	Greg Schafer <gschafer@zip.com.au>
Bug-Reference-ID:	<20061012084940.GA15768@tigers.local>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2006-10/msg00046.html

Bug-Description:

When using historical ``-style command substitution, bash incorrectly attempts
to interpret shell comments while scanning for the closing backquote.

Patch:

*** ../bash-3.2/parse.y	Tue Sep 19 16:37:21 2006
--- parse.y	Thu Oct 12 10:30:57 2006
***************
*** 2736,2740 ****
    count = 1;
    pass_next_character = backq_backslash = was_dollar = in_comment = 0;
!   check_comment = (flags & P_COMMAND) && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0;
  
    /* RFLAGS is the set of flags we want to pass to recursive calls. */
--- 2736,2740 ----
    count = 1;
    pass_next_character = backq_backslash = was_dollar = in_comment = 0;
!   check_comment = (flags & P_COMMAND) && qc != '`' && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0;
  
    /* RFLAGS is the set of flags we want to pass to recursive calls. */
*** ../bash-3.2/patchlevel.h	Thu Apr 13 08:31:04 2006
--- patchlevel.h	Mon Oct 16 14:22:54 2006
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 0
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */

			     BASH PATCH REPORT
			     =================

Bash-Release: 3.2
Patch-ID: bash32-002

Bug-Reported-by:	Jim Gifford <jim@jg555.com>
Bug-Reference-ID:	<12j2pc3aq35mb04@corp.supernews.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2006-10/msg00082.html

Bug-Description:

An incorrect encoding specification in the Content-Type header causes msgfmt
to fail, which causes `make install' to fail.

Patch:

*** ../bash-3.2/po/ru.po        Tue Jan 10 17:51:03 2006
--- po/ru.po    Mon Oct 16 15:13:23 2006
***************
*** 13,17 ****
  "Language-Team: Russian <ru@li.org>\n"
  "MIME-Version: 1.0\n"
! "Content-Type: text/plain; charset=UTF-8\n"
  "Content-Transfer-Encoding: 8bit\n"
  "Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
--- 13,17 ----
  "Language-Team: Russian <ru@li.org>\n"
  "MIME-Version: 1.0\n"
! "Content-Type: text/plain; charset=KOI8-R\n"
  "Content-Transfer-Encoding: 8bit\n"
  "Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

*** ../bash-3.2/patchlevel.h	Thu Apr 13 08:31:04 2006
--- patchlevel.h	Mon Oct 16 14:22:54 2006
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */

			     BASH PATCH REPORT
			     =================

Bash-Release: 3.2
Patch-ID: bash32-003

Bug-Reported-by:	John Gatewood Ham <zappaman@buraphalinux.org>
Bug-Reference-ID:	<Pine.LNX.4.64.0610121334140.15558@www.buraphalinux.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2006-10/msg00045.html

Bug-Description:

When using the conditional command's `=~' operator to match regular
expressions, the parser did not skip over shell metacharacters in the
regular expression, leading to syntax errors.

Patch:

*** ../bash-3.2-patched/parse.y	Tue Oct 17 11:45:20 2006
--- parse.y	Sat Oct 14 14:56:16 2006
***************
*** 1029,1034 ****
--- 1029,1035 ----
  #define PST_CMDTOKEN	0x1000		/* command token OK - unused */
  #define PST_COMPASSIGN	0x2000		/* parsing x=(...) compound assignment */
  #define PST_ASSIGNOK	0x4000		/* assignment statement ok in this context */
+ #define PST_REGEXP	0x8000		/* parsing an ERE/BRE as a single word */
  
  /* Initial size to allocate for tokens, and the
     amount to grow them by. */
***************
*** 2591,2596 ****
--- 2592,2600 ----
        return (character);
      }
  
+   if (parser_state & PST_REGEXP)
+     goto tokword;
+ 
    /* Shell meta-characters. */
    if MBTEST(shellmeta (character) && ((parser_state & PST_DBLPAREN) == 0))
      {
***************
*** 2698,2703 ****
--- 2702,2708 ----
    if MBTEST(character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND))
      return (character);
  
+ tokword:
    /* Okay, if we got this far, we have to read a word.  Read one,
       and then check it against the known ones. */
    result = read_token_word (character);
***************
*** 3202,3209 ****
        if (tok == WORD && test_binop (yylval.word->word))
  	op = yylval.word;
  #if defined (COND_REGEXP)
!       else if (tok == WORD && STREQ (yylval.word->word,"=~"))
! 	op = yylval.word;
  #endif
        else if (tok == '<' || tok == '>')
  	op = make_word_from_token (tok);  /* ( */
--- 3207,3217 ----
        if (tok == WORD && test_binop (yylval.word->word))
  	op = yylval.word;
  #if defined (COND_REGEXP)
!       else if (tok == WORD && STREQ (yylval.word->word, "=~"))
! 	{
! 	  op = yylval.word;
! 	  parser_state |= PST_REGEXP;
! 	}
  #endif
        else if (tok == '<' || tok == '>')
  	op = make_word_from_token (tok);  /* ( */
***************
*** 3234,3239 ****
--- 3242,3248 ----
  
        /* rhs */
        tok = read_token (READ);
+       parser_state &= ~PST_REGEXP;
        if (tok == WORD)
  	{
  	  tright = make_cond_node (COND_TERM, yylval.word, (COND_COM *)NULL, (COND_COM *)NULL);
***************
*** 3419,3427 ****
  	  goto next_character;
  	}
  
  #ifdef EXTENDED_GLOB
        /* Parse a ksh-style extended pattern matching specification. */
!       if (extended_glob && PATTERN_CHAR (character))
  	{
  	  peek_char = shell_getc (1);
  	  if MBTEST(peek_char == '(')		/* ) */
--- 3428,3461 ----
  	  goto next_character;
  	}
  
+ #ifdef COND_REGEXP
+       /* When parsing a regexp as a single word inside a conditional command,
+ 	 we need to special-case characters special to both the shell and
+ 	 regular expressions.  Right now, that is only '(' and '|'. */ /*)*/
+       if MBTEST((parser_state & PST_REGEXP) && (character == '(' || character == '|'))		/*)*/
+         {
+           if (character == '|')
+             goto got_character;
+ 
+ 	  push_delimiter (dstack, character);
+ 	  ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
+ 	  pop_delimiter (dstack);
+ 	  if (ttok == &matched_pair_error)
+ 	    return -1;		/* Bail immediately. */
+ 	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
+ 				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
+ 	  token[token_index++] = character;
+ 	  strcpy (token + token_index, ttok);
+ 	  token_index += ttoklen;
+ 	  FREE (ttok);
+ 	  dollar_present = all_digit_token = 0;
+ 	  goto next_character;
+         }
+ #endif /* COND_REGEXP */
+ 
  #ifdef EXTENDED_GLOB
        /* Parse a ksh-style extended pattern matching specification. */
!       if MBTEST(extended_glob && PATTERN_CHAR (character))
  	{
  	  peek_char = shell_getc (1);
  	  if MBTEST(peek_char == '(')		/* ) */

*** ../bash-3.2/patchlevel.h	Thu Apr 13 08:31:04 2006
--- patchlevel.h	Mon Oct 16 14:22:54 2006
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */


			     BASH PATCH REPORT
			     =================

Bash-Release: 3.2
Patch-ID: bash32-004

Bug-Reported-by:	Stuart Shelton <srcshelton@gmail.com>
Bug-Reference-ID:	<619141e40610261203y6cda5aa6i23cb24c7aeba996e@mail.gmail.com>
Bug-Reference-URL:	

Bug-Description:

A bug in the parameter pattern substitution implementation treated a pattern
whose first character was `/' (after expansion) as specifying global
replacement.

Patch:

*** ../bash-3.2/subst.c	Tue Sep 19 08:35:09 2006
--- subst.c	Thu Oct 26 09:17:50 2006
***************
*** 5707,5712 ****
--- 5707,5717 ----
    vtype &= ~VT_STARSUB;
  
    mflags = 0;
+   if (patsub && *patsub == '/')
+     {
+       mflags |= MATCH_GLOBREP;
+       patsub++;
+     }
  
    /* Malloc this because expand_string_if_necessary or one of the expansion
       functions in its call chain may free it on a substitution error. */
***************
*** 5741,5753 ****
      }
  
    /* ksh93 doesn't allow the match specifier to be a part of the expanded
!      pattern.  This is an extension. */
    p = pat;
!   if (pat && pat[0] == '/')
!     {
!       mflags |= MATCH_GLOBREP|MATCH_ANY;
!       p++;
!     }
    else if (pat && pat[0] == '#')
      {
        mflags |= MATCH_BEG;
--- 5746,5757 ----
      }
  
    /* ksh93 doesn't allow the match specifier to be a part of the expanded
!      pattern.  This is an extension.  Make sure we don't anchor the pattern
!      at the beginning or end of the string if we're doing global replacement,
!      though. */
    p = pat;
!   if (mflags & MATCH_GLOBREP)
!     mflags |= MATCH_ANY;
    else if (pat && pat[0] == '#')
      {
        mflags |= MATCH_BEG;
*** ../bash-3.2/tests/new-exp.right	Thu Aug 10 12:00:00 2006
--- tests/new-exp.right	Sun Oct 29 16:03:36 2006
***************
*** 430,436 ****
  Case06---1---A B C::---
  Case07---3---A:B:C---
  Case08---3---A:B:C---
! ./new-exp.tests: line 506: /${$(($#-1))}: bad substitution
  argv[1] = <a>
  argv[2] = <b>
  argv[3] = <c>
--- 430,436 ----
  Case06---1---A B C::---
  Case07---3---A:B:C---
  Case08---3---A:B:C---
! ./new-exp.tests: line 506: ${$(($#-1))}: bad substitution
  argv[1] = <a>
  argv[2] = <b>
  argv[3] = <c>
*** ../bash-3.2/patchlevel.h	Thu Apr 13 08:31:04 2006
--- patchlevel.h	Mon Oct 16 14:22:54 2006
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */

			     BASH PATCH REPORT
			     =================

Bash-Release: 3.2
Patch-ID: bash32-005

Bug-Reported-by:	Stuart Shelton <stuart@openobjects.com>
Bug-Reference-ID:	<453F7CC8.6030907@openobjects.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2006-10/msg00127.html

Bug-Description:

A missing extern declaration for `asprintf' caused `double' arguments to be
passed as `0', leading to incorrect results.  Additionally, a bug in the
replacement asprintf/snprintf function caused an infinite loop when passed
0 arguments to the floating point conversions under some circumstances.

Patch:

*** ../bash-3.2/builtins/printf.def	Mon Sep 18 08:48:42 2006
--- builtins/printf.def	Tue Oct 31 08:19:44 2006
***************
*** 49,54 ****
--- 49,60 ----
  #  define INT_MIN		(-2147483647-1)
  #endif
  
+ #if defined (PREFER_STDARG)
+ #  include <stdarg.h>
+ #else
+ #  include <varargs.h>
+ #endif
+ 
  #include <stdio.h>
  #include <chartypes.h>
  
***************
*** 151,156 ****
--- 157,166 ----
  #define SKIP1 "#'-+ 0"
  #define LENMODS "hjlLtz"
  
+ #ifndef HAVE_ASPRINTF
+ extern int asprintf __P((char **, const char *, ...)) __attribute__((__format__ (printf, 2, 3)));
+ #endif
+ 
  static void printf_erange __P((char *));
  static int printstr __P((char *, char *, int, int, int));
  static int tescape __P((char *, char *, int *));


*** ../bash-3.2/lib/sh/snprintf.c	Thu Apr  6 09:48:40 2006
--- lib/sh/snprintf.c	Sat Oct 28 00:00:13 2006
***************
*** 471,476 ****
--- 476,483 ----
  	  10^x ~= r
   * log_10(200) = 2;
   * log_10(250) = 2;
+  *
+  * NOTE: do not call this with r == 0 -- an infinite loop results.
   */
  static int
  log_10(r)
***************
*** 576,583 ****
      { 
        integral_part[0] = '0';
        integral_part[1] = '\0';
!       fraction_part[0] = '0';
!       fraction_part[1] = '\0';
        if (fract)
  	*fract = fraction_part;
        return integral_part;
--- 583,593 ----
      { 
        integral_part[0] = '0';
        integral_part[1] = '\0';
!       /* The fractional part has to take the precision into account */
!       for (ch = 0; ch < precision-1; ch++)
!  	fraction_part[ch] = '0';
!       fraction_part[ch] = '0';
!       fraction_part[ch+1] = '\0';
        if (fract)
  	*fract = fraction_part;
        return integral_part;
***************
*** 805,810 ****
--- 815,821 ----
        PUT_CHAR(*tmp, p);
        tmp++;
      }
+ 
    PAD_LEFT(p);
  }
  
***************
*** 972,982 ****
    if ((p->flags & PF_THOUSANDS) && grouping && (t = groupnum (tmp)))
      tmp = t;
  
    /* calculate the padding. 1 for the dot */
    p->width = p->width -
  	    ((d > 0. && p->justify == RIGHT) ? 1:0) -
  	    ((p->flags & PF_SPACE) ? 1:0) -
! 	    strlen(tmp) - p->precision - 1;
    PAD_RIGHT(p);  
    PUT_PLUS(d, p, 0.);
    PUT_SPACE(d, p, 0.);
--- 983,1003 ----
    if ((p->flags & PF_THOUSANDS) && grouping && (t = groupnum (tmp)))
      tmp = t;
  
+   if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)
+     {
+       /* smash the trailing zeros unless altform */
+       for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)
+         tmp2[i] = '\0'; 
+       if (tmp2[0] == '\0')
+ 	p->precision = 0;
+     }
+ 
    /* calculate the padding. 1 for the dot */
    p->width = p->width -
  	    ((d > 0. && p->justify == RIGHT) ? 1:0) -
  	    ((p->flags & PF_SPACE) ? 1:0) -
! 	    strlen(tmp) - p->precision -
! 	    ((p->precision != 0 || (p->flags & PF_ALTFORM)) ? 1 : 0);	/* radix char */
    PAD_RIGHT(p);  
    PUT_PLUS(d, p, 0.);
    PUT_SPACE(d, p, 0.);
***************
*** 991,1001 ****
    if (p->precision != 0 || (p->flags & PF_ALTFORM))
      PUT_CHAR(decpoint, p);  /* put the '.' */
  
-   if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)
-     /* smash the trailing zeros unless altform */
-     for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)
-       tmp2[i] = '\0'; 
- 
    for (; *tmp2; tmp2++)
      PUT_CHAR(*tmp2, p); /* the fraction */
    
--- 1012,1017 ----
***************
*** 1011,1024 ****
    char *tmp, *tmp2;
    int j, i;
  
!   if (chkinfnan(p, d, 1) || chkinfnan(p, d, 2))
      return;	/* already printed nan or inf */
  
    GETLOCALEDATA(decpoint, thoussep, grouping);
    DEF_PREC(p);
!   j = log_10(d);
!   d = d / pow_10(j);  /* get the Mantissa */
!   d = ROUND(d, p);		  
    tmp = dtoa(d, p->precision, &tmp2);
  
    /* 1 for unit, 1 for the '.', 1 for 'e|E',
--- 1027,1045 ----
    char *tmp, *tmp2;
    int j, i;
  
!   if (d != 0 && (chkinfnan(p, d, 1) || chkinfnan(p, d, 2)))
      return;	/* already printed nan or inf */
  
    GETLOCALEDATA(decpoint, thoussep, grouping);
    DEF_PREC(p);
!   if (d == 0.)
!     j = 0;
!   else
!     {
!       j = log_10(d);
!       d = d / pow_10(j);  /* get the Mantissa */
!       d = ROUND(d, p);		  
!     }
    tmp = dtoa(d, p->precision, &tmp2);
  
    /* 1 for unit, 1 for the '.', 1 for 'e|E',
***************
*** 1076,1081 ****
--- 1097,1103 ----
         PUT_CHAR(*tmp, p);
         tmp++;
       }
+ 
     PAD_LEFT(p);
  }
  #endif
***************
*** 1358,1364 ****
  		STAR_ARGS(data);
  		DEF_PREC(data);
  		d = GETDOUBLE(data);
! 		i = log_10(d);
  		/*
  		 * for '%g|%G' ANSI: use f if exponent
  		 * is in the range or [-4,p] exclusively
--- 1380,1386 ----
  		STAR_ARGS(data);
  		DEF_PREC(data);
  		d = GETDOUBLE(data);
! 		i = (d != 0.) ? log_10(d) : -1;
  		/*
  		 * for '%g|%G' ANSI: use f if exponent
  		 * is in the range or [-4,p] exclusively
*** ../bash-3.2/patchlevel.h	Thu Apr 13 08:31:04 2006
--- patchlevel.h	Mon Oct 16 14:22:54 2006
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 5
  
  #endif /* _PATCHLEVEL_H_ */

			     BASH PATCH REPORT
			     =================

Bash-Release: 3.2
Patch-ID: bash32-006

Bug-Reported-by:	ebb9@byu.net
Bug-Reference-ID:	<45540862.9030900@byu.net>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2006-11/msg00017.html
			http://lists.gnu.org/archive/html/bug-bash/2006-11/msg00016.html

Bug-Description:

In some cases, code that is intended to be used in the presence of multibyte
characters is called when no such characters are present, leading to incorrect
display position calculations and incorrect redisplay.

Patch:

*** ../bash-3.2-patched/lib/readline/display.c	Thu Sep 14 14:20:12 2006
--- lib/readline/display.c	Mon Nov 13 17:55:57 2006
***************
*** 2381,2384 ****
--- 2409,2414 ----
    if (end <= start)
      return 0;
+   if (MB_CUR_MAX == 1 || rl_byte_oriented)
+     return (end - start);
  
    memset (&ps, 0, sizeof (mbstate_t));
*** ../bash-3.2/patchlevel.h	Thu Apr 13 08:31:04 2006
--- patchlevel.h	Mon Oct 16 14:22:54 2006
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 5
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 6
  
  #endif /* _PATCHLEVEL_H_ */

			     BASH PATCH REPORT
			     =================

Bash-Release: 3.2
Patch-ID: bash32-007

Bug-Reported-by:	jidanni@jidanni.org
Bug-Reference-ID:	<E1Gkg12-00017D-Fm@jidanni.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2006-11/msg00039.html

Bug-Description:

When removing the current or previous job from the jobs list, bash incorrectly
resets the current job under some circumstances.

Patch:

*** ../bash-3.2-patched/jobs.c	Sat Jul 29 16:40:48 2006
--- jobs.c	Fri Nov 24 14:50:01 2006
***************
*** 985,990 ****
    if (temp == 0)
      return;
-   if (job_index == js.j_current || job_index == js.j_previous)
-     reset_current ();
  
    if ((dflags & DEL_NOBGPID) == 0)
--- 985,988 ----
***************
*** 1029,1032 ****
--- 1027,1033 ----
    else if (jobs[js.j_firstj] == 0 || jobs[js.j_lastj] == 0)
      reset_job_indices ();
+ 
+   if (job_index == js.j_current || job_index == js.j_previous)
+     reset_current ();
  }

*** ../bash-3.2/patchlevel.h	Thu Apr 13 08:31:04 2006
--- patchlevel.h	Mon Oct 16 14:22:54 2006
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 6
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 7
  
  #endif /* _PATCHLEVEL_H_ */

  

			     BASH PATCH REPORT
			     =================

Bash-Release: 3.2
Patch-ID: bash32-008

Bug-Reported-by:	Linda Walsh <bash@tlinx.org>
Bug-Reference-ID:	<456041FD.8000605@tlinx.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2006-11/msg00040.html

Bug-Description:

When checking pathnames from the command hash table (e.g., when the `checkhash'
shell option is enabled), a bug causes bash to delete and re-lookup each
command.

Patch:

*** ../bash-3.2-patched/findcmd.c	Wed Aug 17 16:49:54 2005
--- findcmd.c	Fri Nov 24 10:48:37 2006
***************
*** 309,313 ****
      {
        st = file_status (hashed_file);
!       if ((st ^ (FS_EXISTS | FS_EXECABLE)) != 0)
  	{
  	  phash_remove (pathname);
--- 309,313 ----
      {
        st = file_status (hashed_file);
!       if ((st & (FS_EXISTS|FS_EXECABLE)) != (FS_EXISTS|FS_EXECABLE))
  	{
  	  phash_remove (pathname);
*** ../bash-3.2/patchlevel.h	Thu Apr 13 08:31:04 2006
--- patchlevel.h	Mon Oct 16 14:22:54 2006
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 7
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 8
  
  #endif /* _PATCHLEVEL_H_ */

			     BASH PATCH REPORT
			     =================

Bash-Release: 3.2
Patch-ID: bash32-009

Bug-Reported-by:	James.M.Botte@lowes.com
Bug-Reference-ID:	<BA9FF90F7E5B424998F98EDA9F1F94BE01FA9853@msexchdb01.lowes.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2006-12/msg00000.html

Bug-Description:

When using its built-in replacement for snprintf/asprintf, bash does not
treat the %x, %X, and %o format specifiers as unsigned numbers.

Patch:

*** ../bash-3.2-patched/lib/sh/snprintf.c	Mon Nov 13 08:58:52 2006
--- lib/sh/snprintf.c	Wed Dec  6 11:15:04 2006
***************
*** 669,673 ****
  
    sd = d;	/* signed for ' ' padding in base 10 */
!   flags = (*p->pf == 'u' || *p->pf == 'U') ? FL_UNSIGNED : 0;
    if (*p->pf == 'X')
      flags |= FL_HEXUPPER;
--- 674,679 ----
  
    sd = d;	/* signed for ' ' padding in base 10 */
!   flags = 0;
!   flags = (*p->pf == 'x' || *p->pf == 'X' || *p->pf == 'o' || *p->pf == 'u' || *p->pf == 'U') ? FL_UNSIGNED : 0;
    if (*p->pf == 'X')
      flags |= FL_HEXUPPER;
***************
*** 739,743 ****
  
    sd = d;	/* signed for ' ' padding in base 10 */
!   flags = (*p->pf == 'u' || *p->pf == 'U') ? FL_UNSIGNED : 0;
    if (*p->pf == 'X')
      flags |= FL_HEXUPPER;
--- 745,749 ----
  
    sd = d;	/* signed for ' ' padding in base 10 */
!   flags = (*p->pf == 'x' || *p->pf == 'X' || *p->pf == 'o' || *p->pf == 'u' || *p->pf == 'U') ? FL_UNSIGNED : 0;
    if (*p->pf == 'X')
      flags |= FL_HEXUPPER;
*** ../bash-3.2/patchlevel.h	Thu Apr 13 08:31:04 2006
--- patchlevel.h	Mon Oct 16 14:22:54 2006
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 8
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 9
  
  #endif /* _PATCHLEVEL_H_ */

			     BASH PATCH REPORT
			     =================

Bash-Release: 3.2
Patch-ID: bash32-010

Bug-Reported-by:	Ryan Waldron <rew@erebor.com>
Bug-Reference-ID:	<20070119065603.546D011E9C@kansas.erebor.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2007-01/msg00059.html

Bug-Description:

The glibc implementation of regcomp/regexec does not allow backslashes to
escape "ordinary" pattern characters when matching.  Bash used backslashes
to quote all characters when the pattern argument to the [[ special
command's =~ operator was quoted.  This caused the match to fail on Linux
and other systems using GNU libc.

Patch:

*** ../bash-3.2.9/pathexp.h	Sat Feb 19 17:23:18 2005
--- pathexp.h	Wed Jan 31 22:53:16 2007
***************
*** 1,5 ****
  /* pathexp.h -- The shell interface to the globbing library. */
  
! /* Copyright (C) 1987-2005 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
--- 1,5 ----
  /* pathexp.h -- The shell interface to the globbing library. */
  
! /* Copyright (C) 1987-2007 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
***************
*** 33,36 ****
--- 33,37 ----
  #define QGLOB_CVTNULL	0x01	/* convert QUOTED_NULL strings to '\0' */
  #define QGLOB_FILENAME	0x02	/* do correct quoting for matching filenames */
+ #define QGLOB_REGEXP	0x04	/* quote an ERE for regcomp/regexec */
  
  #if defined (EXTENDED_GLOB)
*** ../bash-3.2.9/pathexp.c	Mon May  6 13:43:05 2002
--- pathexp.c	Mon Feb 26 16:59:23 2007
***************
*** 1,5 ****
  /* pathexp.c -- The shell interface to the globbing library. */
  
! /* Copyright (C) 1995-2002 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
--- 1,5 ----
  /* pathexp.c -- The shell interface to the globbing library. */
  
! /* Copyright (C) 1995-2007 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
***************
*** 111,114 ****
--- 111,141 ----
  }
  
+ /* Return 1 if C is a character that is `special' in a POSIX ERE and needs to
+    be quoted to match itself. */
+ static inline int
+ ere_char (c)
+      int c;
+ {
+   switch (c)
+     {
+     case '.':
+     case '[':
+     case '\\':
+     case '(':
+     case ')':
+     case '*':
+     case '+':
+     case '?':
+     case '{':
+     case '|':
+     case '^':
+     case '$':
+       return 1;
+     default: 
+       return 0;
+     }
+   return (0);
+ }
+ 
  /* PATHNAME can contain characters prefixed by CTLESC; this indicates
     that the character is to be quoted.  We quote it here in the style
***************
*** 143,146 ****
--- 170,175 ----
  	  if ((qflags & QGLOB_FILENAME) && pathname[i+1] == '/')
  	    continue;
+ 	  if ((qflags & QGLOB_REGEXP) && ere_char (pathname[i+1]) == 0)
+ 	    continue;
  	  temp[j++] = '\\';
  	  i++;
*** ../bash-3.2.9/subst.c	Tue Nov  7 16:14:41 2006
--- subst.c	Wed Jan 31 23:09:58 2007
***************
*** 5,9 ****
       beauty, but, hey, you're alright.'' */
  
! /* Copyright (C) 1987-2006 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
--- 5,9 ----
       beauty, but, hey, you're alright.'' */
  
! /* Copyright (C) 1987-2007 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
***************
*** 2647,2655 ****
  /* This needs better error handling. */
  /* Expand W for use as an argument to a unary or binary operator in a
!    [[...]] expression.  If SPECIAL is nonzero, this is the rhs argument
     to the != or == operator, and should be treated as a pattern.  In
!    this case, we quote the string specially for the globbing code.  The
!    caller is responsible for removing the backslashes if the unquoted
!    words is needed later. */   
  char *
  cond_expand_word (w, special)
--- 2647,2656 ----
  /* This needs better error handling. */
  /* Expand W for use as an argument to a unary or binary operator in a
!    [[...]] expression.  If SPECIAL is 1, this is the rhs argument
     to the != or == operator, and should be treated as a pattern.  In
!    this case, we quote the string specially for the globbing code.  If
!    SPECIAL is 2, this is an rhs argument for the =~ operator, and should
!    be quoted appropriately for regcomp/regexec.  The caller is responsible
!    for removing the backslashes if the unquoted word is needed later. */   
  char *
  cond_expand_word (w, special)
***************
*** 2659,2662 ****
--- 2660,2664 ----
    char *r, *p;
    WORD_LIST *l;
+   int qflags;
  
    if (w->word == 0 || w->word[0] == '\0')
***************
*** 2673,2678 ****
        else
  	{
  	  p = string_list (l);
! 	  r = quote_string_for_globbing (p, QGLOB_CVTNULL);
  	  free (p);
  	}
--- 2675,2683 ----
        else
  	{
+ 	  qflags = QGLOB_CVTNULL;
+ 	  if (special == 2)
+ 	    qflags |= QGLOB_REGEXP;
  	  p = string_list (l);
! 	  r = quote_string_for_globbing (p, qflags);
  	  free (p);
  	}
*** ../bash-3.2.9/execute_cmd.c	Sat Aug 26 00:23:17 2006
--- execute_cmd.c	Wed Jan 31 23:12:06 2007
***************
*** 1,5 ****
  /* execute_cmd.c -- Execute a COMMAND structure. */
  
! /* Copyright (C) 1987-2005 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
--- 1,5 ----
  /* execute_cmd.c -- Execute a COMMAND structure. */
  
! /* Copyright (C) 1987-2007 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
***************
*** 2547,2551 ****
        if (arg1 == 0)
  	arg1 = nullstr;
!       arg2 = cond_expand_word (cond->right->op, patmatch||rmatch);
        if (arg2 == 0)
  	arg2 = nullstr;
--- 2547,2551 ----
        if (arg1 == 0)
  	arg1 = nullstr;
!       arg2 = cond_expand_word (cond->right->op, rmatch ? 2 : (patmatch ? 1 : 0));
        if (arg2 == 0)
  	arg2 = nullstr;
*** ../bash-3.2/patchlevel.h	Thu Apr 13 08:31:04 2006
--- patchlevel.h	Mon Oct 16 14:22:54 2006
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 9
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 10
  
  #endif /* _PATCHLEVEL_H_ */
