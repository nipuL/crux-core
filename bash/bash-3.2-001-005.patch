			     BASH PATCH REPORT
			     =================

Bash-Release: 3.2
Patch-ID: bash32-001

Bug-Reported-by:	Greg Schafer <gschafer@zip.com.au>
Bug-Reference-ID:	<20061012084940.GA15768@tigers.local>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2006-10/msg00046.html

Bug-Description:

When using historical ``-style command substitution, bash incorrectly attempts
to interpret shell comments while scanning for the closing backquote.

Patch:

*** ../bash-3.2/parse.y	Tue Sep 19 16:37:21 2006
--- parse.y	Thu Oct 12 10:30:57 2006
***************
*** 2736,2740 ****
    count = 1;
    pass_next_character = backq_backslash = was_dollar = in_comment = 0;
!   check_comment = (flags & P_COMMAND) && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0;
  
    /* RFLAGS is the set of flags we want to pass to recursive calls. */
--- 2736,2740 ----
    count = 1;
    pass_next_character = backq_backslash = was_dollar = in_comment = 0;
!   check_comment = (flags & P_COMMAND) && qc != '`' && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0;
  
    /* RFLAGS is the set of flags we want to pass to recursive calls. */
*** ../bash-3.2/patchlevel.h	Thu Apr 13 08:31:04 2006
--- patchlevel.h	Mon Oct 16 14:22:54 2006
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 0
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.2
Patch-ID: bash32-002

Bug-Reported-by:	Jim Gifford <jim@jg555.com>
Bug-Reference-ID:	<12j2pc3aq35mb04@corp.supernews.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2006-10/msg00082.html

Bug-Description:

An incorrect encoding specification in the Content-Type header causes msgfmt
to fail, which causes `make install' to fail.

Patch:

*** ../bash-3.2/po/ru.po        Tue Jan 10 17:51:03 2006
--- po/ru.po    Mon Oct 16 15:13:23 2006
***************
*** 13,17 ****
  "Language-Team: Russian <ru@li.org>\n"
  "MIME-Version: 1.0\n"
! "Content-Type: text/plain; charset=UTF-8\n"
  "Content-Transfer-Encoding: 8bit\n"
  "Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
--- 13,17 ----
  "Language-Team: Russian <ru@li.org>\n"
  "MIME-Version: 1.0\n"
! "Content-Type: text/plain; charset=KOI8-R\n"
  "Content-Transfer-Encoding: 8bit\n"
  "Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

*** ../bash-3.2/patchlevel.h	Thu Apr 13 08:31:04 2006
--- patchlevel.h	Mon Oct 16 14:22:54 2006
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.2
Patch-ID: bash32-003

Bug-Reported-by:	John Gatewood Ham <zappaman@buraphalinux.org>
Bug-Reference-ID:	<Pine.LNX.4.64.0610121334140.15558@www.buraphalinux.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2006-10/msg00045.html

Bug-Description:

When using the conditional command's `=~' operator to match regular
expressions, the parser did not skip over shell metacharacters in the
regular expression, leading to syntax errors.

Patch:

*** ../bash-3.2-patched/parse.y	Tue Oct 17 11:45:20 2006
--- parse.y	Sat Oct 14 14:56:16 2006
***************
*** 1029,1034 ****
--- 1029,1035 ----
  #define PST_CMDTOKEN	0x1000		/* command token OK - unused */
  #define PST_COMPASSIGN	0x2000		/* parsing x=(...) compound assignment */
  #define PST_ASSIGNOK	0x4000		/* assignment statement ok in this context */
+ #define PST_REGEXP	0x8000		/* parsing an ERE/BRE as a single word */
  
  /* Initial size to allocate for tokens, and the
     amount to grow them by. */
***************
*** 2591,2596 ****
--- 2592,2600 ----
        return (character);
      }
  
+   if (parser_state & PST_REGEXP)
+     goto tokword;
+ 
    /* Shell meta-characters. */
    if MBTEST(shellmeta (character) && ((parser_state & PST_DBLPAREN) == 0))
      {
***************
*** 2698,2703 ****
--- 2702,2708 ----
    if MBTEST(character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND))
      return (character);
  
+ tokword:
    /* Okay, if we got this far, we have to read a word.  Read one,
       and then check it against the known ones. */
    result = read_token_word (character);
***************
*** 3202,3209 ****
        if (tok == WORD && test_binop (yylval.word->word))
  	op = yylval.word;
  #if defined (COND_REGEXP)
!       else if (tok == WORD && STREQ (yylval.word->word,"=~"))
! 	op = yylval.word;
  #endif
        else if (tok == '<' || tok == '>')
  	op = make_word_from_token (tok);  /* ( */
--- 3207,3217 ----
        if (tok == WORD && test_binop (yylval.word->word))
  	op = yylval.word;
  #if defined (COND_REGEXP)
!       else if (tok == WORD && STREQ (yylval.word->word, "=~"))
! 	{
! 	  op = yylval.word;
! 	  parser_state |= PST_REGEXP;
! 	}
  #endif
        else if (tok == '<' || tok == '>')
  	op = make_word_from_token (tok);  /* ( */
***************
*** 3234,3239 ****
--- 3242,3248 ----
  
        /* rhs */
        tok = read_token (READ);
+       parser_state &= ~PST_REGEXP;
        if (tok == WORD)
  	{
  	  tright = make_cond_node (COND_TERM, yylval.word, (COND_COM *)NULL, (COND_COM *)NULL);
***************
*** 3419,3427 ****
  	  goto next_character;
  	}
  
  #ifdef EXTENDED_GLOB
        /* Parse a ksh-style extended pattern matching specification. */
!       if (extended_glob && PATTERN_CHAR (character))
  	{
  	  peek_char = shell_getc (1);
  	  if MBTEST(peek_char == '(')		/* ) */
--- 3428,3461 ----
  	  goto next_character;
  	}
  
+ #ifdef COND_REGEXP
+       /* When parsing a regexp as a single word inside a conditional command,
+ 	 we need to special-case characters special to both the shell and
+ 	 regular expressions.  Right now, that is only '(' and '|'. */ /*)*/
+       if MBTEST((parser_state & PST_REGEXP) && (character == '(' || character == '|'))		/*)*/
+         {
+           if (character == '|')
+             goto got_character;
+ 
+ 	  push_delimiter (dstack, character);
+ 	  ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
+ 	  pop_delimiter (dstack);
+ 	  if (ttok == &matched_pair_error)
+ 	    return -1;		/* Bail immediately. */
+ 	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
+ 				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
+ 	  token[token_index++] = character;
+ 	  strcpy (token + token_index, ttok);
+ 	  token_index += ttoklen;
+ 	  FREE (ttok);
+ 	  dollar_present = all_digit_token = 0;
+ 	  goto next_character;
+         }
+ #endif /* COND_REGEXP */
+ 
  #ifdef EXTENDED_GLOB
        /* Parse a ksh-style extended pattern matching specification. */
!       if MBTEST(extended_glob && PATTERN_CHAR (character))
  	{
  	  peek_char = shell_getc (1);
  	  if MBTEST(peek_char == '(')		/* ) */

*** ../bash-3.2/patchlevel.h	Thu Apr 13 08:31:04 2006
--- patchlevel.h	Mon Oct 16 14:22:54 2006
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */

			     BASH PATCH REPORT
			     =================

Bash-Release: 3.2
Patch-ID: bash32-004

Bug-Reported-by:	Stuart Shelton <srcshelton@gmail.com>
Bug-Reference-ID:	<619141e40610261203y6cda5aa6i23cb24c7aeba996e@mail.gmail.com>
Bug-Reference-URL:	

Bug-Description:

A bug in the parameter pattern substitution implementation treated a pattern
whose first character was `/' (after expansion) as specifying global
replacement.

Patch:

*** ../bash-3.2/subst.c	Tue Sep 19 08:35:09 2006
--- subst.c	Thu Oct 26 09:17:50 2006
***************
*** 5707,5712 ****
--- 5707,5717 ----
    vtype &= ~VT_STARSUB;
  
    mflags = 0;
+   if (patsub && *patsub == '/')
+     {
+       mflags |= MATCH_GLOBREP;
+       patsub++;
+     }
  
    /* Malloc this because expand_string_if_necessary or one of the expansion
       functions in its call chain may free it on a substitution error. */
***************
*** 5741,5753 ****
      }
  
    /* ksh93 doesn't allow the match specifier to be a part of the expanded
!      pattern.  This is an extension. */
    p = pat;
!   if (pat && pat[0] == '/')
!     {
!       mflags |= MATCH_GLOBREP|MATCH_ANY;
!       p++;
!     }
    else if (pat && pat[0] == '#')
      {
        mflags |= MATCH_BEG;
--- 5746,5757 ----
      }
  
    /* ksh93 doesn't allow the match specifier to be a part of the expanded
!      pattern.  This is an extension.  Make sure we don't anchor the pattern
!      at the beginning or end of the string if we're doing global replacement,
!      though. */
    p = pat;
!   if (mflags & MATCH_GLOBREP)
!     mflags |= MATCH_ANY;
    else if (pat && pat[0] == '#')
      {
        mflags |= MATCH_BEG;
*** ../bash-3.2/tests/new-exp.right	Thu Aug 10 12:00:00 2006
--- tests/new-exp.right	Sun Oct 29 16:03:36 2006
***************
*** 430,436 ****
  Case06---1---A B C::---
  Case07---3---A:B:C---
  Case08---3---A:B:C---
! ./new-exp.tests: line 506: /${$(($#-1))}: bad substitution
  argv[1] = <a>
  argv[2] = <b>
  argv[3] = <c>
--- 430,436 ----
  Case06---1---A B C::---
  Case07---3---A:B:C---
  Case08---3---A:B:C---
! ./new-exp.tests: line 506: ${$(($#-1))}: bad substitution
  argv[1] = <a>
  argv[2] = <b>
  argv[3] = <c>
*** ../bash-3.2/patchlevel.h	Thu Apr 13 08:31:04 2006
--- patchlevel.h	Mon Oct 16 14:22:54 2006
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.2
Patch-ID: bash32-005

Bug-Reported-by:	Stuart Shelton <stuart@openobjects.com>
Bug-Reference-ID:	<453F7CC8.6030907@openobjects.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2006-10/msg00127.html

Bug-Description:

A missing extern declaration for `asprintf' caused `double' arguments to be
passed as `0', leading to incorrect results.  Additionally, a bug in the
replacement asprintf/snprintf function caused an infinite loop when passed
0 arguments to the floating point conversions under some circumstances.

Patch:

*** ../bash-3.2/builtins/printf.def	Mon Sep 18 08:48:42 2006
--- builtins/printf.def	Tue Oct 31 08:19:44 2006
***************
*** 49,54 ****
--- 49,60 ----
  #  define INT_MIN		(-2147483647-1)
  #endif
  
+ #if defined (PREFER_STDARG)
+ #  include <stdarg.h>
+ #else
+ #  include <varargs.h>
+ #endif
+ 
  #include <stdio.h>
  #include <chartypes.h>
  
***************
*** 151,156 ****
--- 157,166 ----
  #define SKIP1 "#'-+ 0"
  #define LENMODS "hjlLtz"
  
+ #ifndef HAVE_ASPRINTF
+ extern int asprintf __P((char **, const char *, ...)) __attribute__((__format__ (printf, 2, 3)));
+ #endif
+ 
  static void printf_erange __P((char *));
  static int printstr __P((char *, char *, int, int, int));
  static int tescape __P((char *, char *, int *));


*** ../bash-3.2/lib/sh/snprintf.c	Thu Apr  6 09:48:40 2006
--- lib/sh/snprintf.c	Sat Oct 28 00:00:13 2006
***************
*** 471,476 ****
--- 476,483 ----
  	  10^x ~= r
   * log_10(200) = 2;
   * log_10(250) = 2;
+  *
+  * NOTE: do not call this with r == 0 -- an infinite loop results.
   */
  static int
  log_10(r)
***************
*** 576,583 ****
      { 
        integral_part[0] = '0';
        integral_part[1] = '\0';
!       fraction_part[0] = '0';
!       fraction_part[1] = '\0';
        if (fract)
  	*fract = fraction_part;
        return integral_part;
--- 583,593 ----
      { 
        integral_part[0] = '0';
        integral_part[1] = '\0';
!       /* The fractional part has to take the precision into account */
!       for (ch = 0; ch < precision-1; ch++)
!  	fraction_part[ch] = '0';
!       fraction_part[ch] = '0';
!       fraction_part[ch+1] = '\0';
        if (fract)
  	*fract = fraction_part;
        return integral_part;
***************
*** 805,810 ****
--- 815,821 ----
        PUT_CHAR(*tmp, p);
        tmp++;
      }
+ 
    PAD_LEFT(p);
  }
  
***************
*** 972,982 ****
    if ((p->flags & PF_THOUSANDS) && grouping && (t = groupnum (tmp)))
      tmp = t;
  
    /* calculate the padding. 1 for the dot */
    p->width = p->width -
  	    ((d > 0. && p->justify == RIGHT) ? 1:0) -
  	    ((p->flags & PF_SPACE) ? 1:0) -
! 	    strlen(tmp) - p->precision - 1;
    PAD_RIGHT(p);  
    PUT_PLUS(d, p, 0.);
    PUT_SPACE(d, p, 0.);
--- 983,1003 ----
    if ((p->flags & PF_THOUSANDS) && grouping && (t = groupnum (tmp)))
      tmp = t;
  
+   if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)
+     {
+       /* smash the trailing zeros unless altform */
+       for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)
+         tmp2[i] = '\0'; 
+       if (tmp2[0] == '\0')
+ 	p->precision = 0;
+     }
+ 
    /* calculate the padding. 1 for the dot */
    p->width = p->width -
  	    ((d > 0. && p->justify == RIGHT) ? 1:0) -
  	    ((p->flags & PF_SPACE) ? 1:0) -
! 	    strlen(tmp) - p->precision -
! 	    ((p->precision != 0 || (p->flags & PF_ALTFORM)) ? 1 : 0);	/* radix char */
    PAD_RIGHT(p);  
    PUT_PLUS(d, p, 0.);
    PUT_SPACE(d, p, 0.);
***************
*** 991,1001 ****
    if (p->precision != 0 || (p->flags & PF_ALTFORM))
      PUT_CHAR(decpoint, p);  /* put the '.' */
  
-   if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)
-     /* smash the trailing zeros unless altform */
-     for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)
-       tmp2[i] = '\0'; 
- 
    for (; *tmp2; tmp2++)
      PUT_CHAR(*tmp2, p); /* the fraction */
    
--- 1012,1017 ----
***************
*** 1011,1024 ****
    char *tmp, *tmp2;
    int j, i;
  
!   if (chkinfnan(p, d, 1) || chkinfnan(p, d, 2))
      return;	/* already printed nan or inf */
  
    GETLOCALEDATA(decpoint, thoussep, grouping);
    DEF_PREC(p);
!   j = log_10(d);
!   d = d / pow_10(j);  /* get the Mantissa */
!   d = ROUND(d, p);		  
    tmp = dtoa(d, p->precision, &tmp2);
  
    /* 1 for unit, 1 for the '.', 1 for 'e|E',
--- 1027,1045 ----
    char *tmp, *tmp2;
    int j, i;
  
!   if (d != 0 && (chkinfnan(p, d, 1) || chkinfnan(p, d, 2)))
      return;	/* already printed nan or inf */
  
    GETLOCALEDATA(decpoint, thoussep, grouping);
    DEF_PREC(p);
!   if (d == 0.)
!     j = 0;
!   else
!     {
!       j = log_10(d);
!       d = d / pow_10(j);  /* get the Mantissa */
!       d = ROUND(d, p);		  
!     }
    tmp = dtoa(d, p->precision, &tmp2);
  
    /* 1 for unit, 1 for the '.', 1 for 'e|E',
***************
*** 1076,1081 ****
--- 1097,1103 ----
         PUT_CHAR(*tmp, p);
         tmp++;
       }
+ 
     PAD_LEFT(p);
  }
  #endif
***************
*** 1358,1364 ****
  		STAR_ARGS(data);
  		DEF_PREC(data);
  		d = GETDOUBLE(data);
! 		i = log_10(d);
  		/*
  		 * for '%g|%G' ANSI: use f if exponent
  		 * is in the range or [-4,p] exclusively
--- 1380,1386 ----
  		STAR_ARGS(data);
  		DEF_PREC(data);
  		d = GETDOUBLE(data);
! 		i = (d != 0.) ? log_10(d) : -1;
  		/*
  		 * for '%g|%G' ANSI: use f if exponent
  		 * is in the range or [-4,p] exclusively
*** ../bash-3.2/patchlevel.h	Thu Apr 13 08:31:04 2006
--- patchlevel.h	Mon Oct 16 14:22:54 2006
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 5
  
  #endif /* _PATCHLEVEL_H_ */
