			   READLINE PATCH REPORT
			   =====================

Readline-Release: 6.0
Patch-ID: readline60-001

Bug-Reported-by: Nicolai Lissner <nlissne@linux01.org>
Bug-Reference-ID: <20090412020510.GA29658@lilith>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2009-04/msg00104.html

Bug-Description:

If a SIGWINCH arrives while bash is performing redisplay, multi-line prompts
are displayed incorrectly due to the display code being called recursively.

Patch:

*** ../readline-6.0/readline.h	2009-01-04 14:32:33.000000000 -0500
--- readline.h	2009-04-13 08:47:00.000000000 -0400
***************
*** 815,820 ****
  #define RL_STATE_MULTIKEY	0x200000	/* reading multiple-key command */
  #define RL_STATE_VICMDONCE	0x400000	/* entered vi command mode at least once */
  
! #define RL_STATE_DONE		0x800000	/* done; accepted line */
  
  #define RL_SETSTATE(x)		(rl_readline_state |= (x))
--- 815,821 ----
  #define RL_STATE_MULTIKEY	0x200000	/* reading multiple-key command */
  #define RL_STATE_VICMDONCE	0x400000	/* entered vi command mode at least once */
+ #define RL_STATE_REDISPLAYING	0x800000	/* updating terminal display */
  
! #define RL_STATE_DONE		0x1000000	/* done; accepted line */
  
  #define RL_SETSTATE(x)		(rl_readline_state |= (x))
*** ../readline-6.0/display.c	2009-01-04 14:32:32.000000000 -0500
--- display.c	2009-04-13 08:29:54.000000000 -0400
***************
*** 513,516 ****
--- 513,517 ----
       data structures. */
    _rl_block_sigint ();  
+   RL_SETSTATE (RL_STATE_REDISPLAYING);
  
    if (!rl_display_prompt)
***************
*** 1237,1240 ****
--- 1238,1242 ----
    }
  
+   RL_UNSETSTATE (RL_STATE_REDISPLAYING);
    _rl_release_sigint ();
  }
*** ../readline-6.0/terminal.c	2009-01-04 14:32:34.000000000 -0500
--- terminal.c	2009-04-13 08:43:00.000000000 -0400
***************
*** 356,360 ****
        if (CUSTOM_REDISPLAY_FUNC ())
  	rl_forced_update_display ();
!       else
  	_rl_redisplay_after_sigwinch ();
      }
--- 356,360 ----
        if (CUSTOM_REDISPLAY_FUNC ())
  	rl_forced_update_display ();
!       else if (RL_ISSTATE(RL_STATE_REDISPLAYING) == 0)
  	_rl_redisplay_after_sigwinch ();
      }
*** ../readline-6.0/patchlevel	2008-11-18 11:01:14.000000000 -0500
--- patchlevel	2009-05-09 12:01:06.000000000 -0400
***************
*** 1,3 ****
  # Do not edit -- exists only for use by patch
  
! 0
--- 1,3 ----
  # Do not edit -- exists only for use by patch
  
! 1
			   READLINE PATCH REPORT
			   =====================

Readline-Release: 6.0
Patch-ID: readline60-002

Bug-Reported-by:  Matt Zyzik <matt.zyzik@nyu.edu>
Bug-Reference-ID: <20090319015542.696F62B8E8@ice.filescope.com>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2009-03/msg00149.html

Bug-Description:

When not in a locale supporting multibyte characters, readline will occasionally
not erase characters between the cursor position and the end of the line
when killing text backwards.

Patch:

*** ../readline-6.0/display.c	2009-01-04 14:32:32.000000000 -0500
--- display.c	2009-04-14 14:00:18.000000000 -0400
***************
*** 1775,1779 ****
  	     adjust col_lendiff based on the difference between _rl_last_c_pos
  	     and _rl_screenwidth */
! 	  if (col_lendiff && (_rl_last_c_pos < _rl_screenwidth))
  #endif
  	    {	  
--- 1775,1779 ----
  	     adjust col_lendiff based on the difference between _rl_last_c_pos
  	     and _rl_screenwidth */
! 	  if (col_lendiff && ((MB_CUR_MAX == 1 || rl_byte_oriented) || (_rl_last_c_pos < _rl_screenwidth)))
  #endif
  	    {	  
*** ../readline-6.0/patchlevel	2008-11-18 11:01:14.000000000 -0500
--- patchlevel	2009-05-09 12:01:06.000000000 -0400
***************
*** 1,3 ****
  # Do not edit -- exists only for use by patch
  
! 1
--- 1,3 ----
  # Do not edit -- exists only for use by patch
  
! 2
			   READLINE PATCH REPORT
			   =====================

Readline-Release: 6.0
Patch-ID: readline60-003

Bug-Reported-by: Andreas Schwab <schwab@linux-m68k.org>
Bug-Reference-ID: <m21vrhhx08.fsf@igel.home>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2009-04/msg00160.html

Bug-Description:

If the prompt length exactly matches the screen width, and the prompt ends
with invisible characters, readline positions the cursor incorrectly.

Patch:

*** ../readline-6.0/display.c	2009-01-04 14:32:32.000000000 -0500
--- display.c	2009-04-25 21:42:18.000000000 -0400
***************
*** 1895,1898 ****
--- 1897,1904 ----
    woff = WRAP_OFFSET (_rl_last_v_pos, wrap_offset);
    cpos = _rl_last_c_pos;
+ 
+   if (cpos == 0 && cpos == new)
+     return;
+ 
  #if defined (HANDLE_MULTIBYTE)
    /* If we have multibyte characters, NEW is indexed by the buffer point in
***************
*** 1908,1914 ****
  	 desired display position. */
        if ((new > prompt_last_invisible) ||		/* XXX - don't use woff here */
! 	  (prompt_physical_chars > _rl_screenwidth &&
  	   _rl_last_v_pos == prompt_last_screen_line &&
! 	   wrap_offset >= woff &&
  	   new > (prompt_last_invisible-(_rl_screenwidth*_rl_last_v_pos)-wrap_offset)))
  	   /* XXX last comparison might need to be >= */
--- 1914,1920 ----
  	 desired display position. */
        if ((new > prompt_last_invisible) ||		/* XXX - don't use woff here */
! 	  (prompt_physical_chars >= _rl_screenwidth &&
  	   _rl_last_v_pos == prompt_last_screen_line &&
! 	   wrap_offset >= woff && dpos >= woff &&
  	   new > (prompt_last_invisible-(_rl_screenwidth*_rl_last_v_pos)-wrap_offset)))
  	   /* XXX last comparison might need to be >= */
*** ../readline-6.0/patchlevel	2008-11-18 11:01:14.000000000 -0500
--- patchlevel	2009-05-09 12:01:06.000000000 -0400
***************
*** 1,3 ****
  # Do not edit -- exists only for use by patch
  
! 2
--- 1,3 ----
  # Do not edit -- exists only for use by patch
  
! 3
